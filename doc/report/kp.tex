\input template.tex
\begin{document}
\selectlanguage{russian}

\setcounter{page}{2}
\normalfont
\tableofcontents
\clearpage
\section*{ВВЕДЕНИЕ}
\addcontentsline{toc}{section}{ВВЕДЕНИЕ}
В данной работе представлен процесс разработки программы, базирующийся на концепциях объектно-ориентированного программирование (ООП), результатом которого является полнофункциональное приложение, написанное на языке Object Pascal, на его варианте, представленном в среде Delphi 7. Поэтому во вступительном слове расскажем немного о методологии ООП и языке Object Pascal.

Объектно-ориентированная парадигма программирования не нова. Её истоки восходят к Симуле-67, хотя первая полная реализация была в Smalltalk-80. ООП (Объектно-ориентированное программирование) стало популярным во второй половине 80-х в таких языках, как С++, Objective C (другое расширение C), Object Pascal и Turbo Pascal, CLOS (ОО-расширение Lisp'a), Eiffel, Ada (в её последних воплощениях) и недавно — в Java. Эта работа сосредоточена на C++,Object Pascal и Java, иногда упоминая и другие языки.

Ключевые черты ООП хорошо известны:

Первая — инкапсуляция — это определение классов — пользовательских типов данных, объединяющих своё содержимое в 
единый тип и реализующих некоторые операции или методы над ним. Классы обычно являются основой модульности, инкапсуляции и абстракции данных в языках ООП.

Вторая ключевая черта, — наследование — есть способ определения нового типа, наследуя элементы (свойства и методы) существующего и модифицируя или расширяя их. Это способствует выражению специализации и генерализации.

Третья черта, известная как полиморфизм, позволяет единообразно ссылаться на объекты различных классов (обычно внутри некоторой иерархии). Это делает классы ещё более удобными и делает программы, основанные на них, легче для расширения и поддержки.

Инкапсуляция, наследование и полиморфизм — фундаментальные свойства, требуемые от языка, претендующего называться объектно-ориентированным (языки, не имеющие наследования и полиморфизма, но имеющие только классы, обычно называются основанными на классах). Различные ОО языки используют совершенно разные подходы. Мы можем различать ОО языки, сравнивая механизм контроля типов, способность поддерживать различные программные модели и то, какие объектные модели они поддерживают.

Алан Кей в свое время вывел пять основных черт языка Smalltalk — первого удачного ОО языка:
Все является объектом. Объект как хранит информацию, так и способен ее преобразовывать. В принципе любой элемент решаемой задачи (дом, собака, услуга, химическая реакция, город, космический корабль и т. д.) может представлять собой объект. Объект можно представить себе как швейцарский нож: он является набором различных ножей и «открывашек» (хранение), но в то же самое время им мы можем резать или открывать что-либо (преобразование).

Программа — совокупность объектов, указывающих друг другу что делать. Для обращения к одному объекту другой объект «посылает ему сообщение». Как вариант возможно и «ответное сообщение». Программу можно представить себе как совокупность к примеру 3 объектов: писателя, ручки и листа бумаги. Писатель «посылает сообщение» ручке, которая в свою очередь «посылает сообщение» листу бумаги — в результате мы видим текст (посыл сообщения от листа к писателю).
Каждый объект имеет свою собственную «память» состоящую из других объектов. Таким образом программист может скрыть сложность программы за довольно простыми объектами. К примеру дом (достаточно сложный объект) состоит из дверей, комнат, окон, проводки и отопления. Дверь в свою очередь может состоять из собственно двери, ручки, замка и петель. Проводка так-же состоит из проводов, розеток и к примеру щитка.

У каждого объекта есть тип. Иногда тип называют еще и классом. Класс (тип) определяет какие сообщения объекты могут посылать друг другу. Например, аккумуляторная батарея может передавать электролампе ток, а вот момент или физическое усилие - нет.

Все объекты одного типа могут получать одинаковые сообщения. К примеру у нас есть 2 объекта: синяя и красная кружки. Обе разные по форме и материалу. Но из обеих мы можем пить (или не пить, если они пустые). В данном случае кружка — это тип объекта.

Самое лаконичное описание объекта предложил Буч: «Объект обладает состоянием, поведением и индивидуальностью».

Языки программирования можно оценить по тому, насколько они строги к типам. Контроль типов включает проверку существования вызываемых методов, типов их параметров, проверку границ массивов и подобное.

Различаются чистые и гибридные объектно-ориентированные языки. Чистые — это те, которые позволяют использовать только одну модель программирования — объектно-ориентированную. Вы можете объявлять классы и методы, но не можете завести глобальные переменные и обычные функции и процедуры старого типа.

 Третий элемент, по которому различаются языки ООП - их объектная модель. Некоторые традиционные языки ООП позволяют программистам создавать объекты в стеке, в куче (в хипе - heap) или в статической памяти. В этих языках переменная типа класс соответствует объекту в памяти. Так работает C++.
В последнее время появилась тенденция использовать другую модель, часто называемую ссылочно-объектной моделью. В этой модели каждый объект динамически размещается в куче, а переменная типа класс фактически является ссылкой или хэндлом объекта в памяти (технически это нечто вроде указателя). Java и Object Pascal оба используют эту ссылочную модель.

Опишем некоторые особенности обьектно-ориентированных языков;

 Если вы создали и использовали объект, вам нужно уничтожить его, чтобы не занимать неиспользуемую память.

При создании объекта какого либо класса вызывается специальный метод этого класса, называемый конструктором, который выполняет все действия по подготовке объекта: выделение памяти, инициализация параметров и т.д.

Деструктор играет роль противоположную конструктору и обычно вызывается при уничтожении объекта. Если конструктор нужен большинству классов, то только некоторые из них нуждаются в деструкторе. Деструктор в основном используется для освобождения ресурсов, зарезервированных конструктором (или другими методами во время жизни объекта). Эти ресурсы включают память, файлы, базы данных, ресурсы ОС и т. д.

Общим элементом всех ООП языков является присутствие трех спецификаторов доступа, указывающих на различные уровни инкапсуляции класса: public, protected, и private. Public означает: видимый любым другим классом, protected означает: видимый производными классами, private означает: отсутствие видимости извне. В деталях, однако, есть различия.

ОО языки обычно разрешают заводить методы и данные, относящиеся к классу целиком, а не к отдельным объектам. Метод класса обычно может быть вызван как для объекта класса, так и применён к классу в целом. Данные класса не повторяются для каждого объекта, а разделяются между всеми объектами данного типа.

Наследование у классов — одно из оснований ООП. Оно может быть использовано для выражения генерализации или специализации. Основная идея в том, что вы определяете новый тип, расширяя или модифицируя существующий, другими словами, производный класс обладает всеми данными и методами базового класса, новыми данными и методами и, возможно, модифицирует некоторые из существующих методов. Различные ОО языки используют различные жаргоны для описания этого механизма (derivation, inheritance, sub-classing), для класса, от которого вы наследуете (базовый класс, родительский класс, суперкласс) и для нового класса (производный класс, дочерний класс, подкласс).

 В некоторых ОО языках каждый класс происходит по крайней мере от некоторого базового класса по умолчанию. Этот класс, часто называемый Object, или подобно этому, обладает некоторыми основными способностями, доступными всем классам. Фактически, все другие классы в обязательном порядке его наследуют. Этот подход является общим ещё и потому, что так первоначально делалось в Smalltalk.

 Когда вы пишете метод класса или перекрываете метод базового класса, вам нередко надо сослаться на методы базового класса. Если этот метод переопределен в производном классе, то, используя его имя, вы получите новую версию. В ОО языках есть некоторые приёмы или ключевые слова, позволяющие решить эту проблему.

 Когда различные классы в иерархии переопределяют некоторый метод, очень полезна возможность ссылаться на общий объект этих классов (благодаря совместимости подклассов) и вызывать этот метод, результатом чего будет вызов метода надлежащего класса. Для этого компилятор должен поддерживать позднее связывание, то есть не генерировать вызов специфической функции, а ждать, пока во время выполнения не определятся фактический тип объекта и функция, которую нужно вызвать.

При построении сложной иерархии, для обеспечения полиморфизма программисты часто вынуждены вводить методы в классы верхнего уровня, даже если эти методы ещё не определены для этой специфической абстракции. Здесь можно было бы оставить пустые методы, но многие ОО языки предлагают такой специфический механизм, как определение абстрактных методов, то есть методов без реализации. Классы, имеющие хотя бы один абстрактный метод, часто называются абстрактными классами.

Некоторые ОО языки допускают наследование более чем одному базовому классу. Другие языки позволяют вам наследовать только от одного класса, но дополнительно позволять вам наследовать также от многочисленных интерфейсов или чисто абстрактных классов, то есть классов, состоящих только из виртуальных функций.

 В строго типизованных ОО языках компилятор осуществляет весь контроль типов, так что нет особой необходимости хранить информацию о классах и типах в работающей программе. Тем не менее, есть случаи (как, например, динамическое преобразование типов), которые требуют информацию о типе. По этой причине все три ОО языка, рассматриваемые здесь, более или менее поддерживают Идентификацию/Информацию о Типе Времени Выполнения (RTTI).

 Основная идея обработки исключений — упростить код обработки ошибок в программе, предоставив стандартный встроенный механизм, с целью сделать программы более устойчивыми. Обработка исключений — это тема, требующая отдельного рассмотрения, поэтому я только очерчу некоторые ключевые элементы и различия.

Теперь скажем несколько слов о языке Delphi.

Delphi — императивный, структурированный, объектно-ориентированный язык программирования, диалект Object Pascal] Начиная со среды разработки Delphi 7.0, в официальных документах Borland стала использовать название Delphi для обозначения языка Object Pascal. Начиная с 2007 года уже язык Delphi (производный от Object Pascal) начал жить своей самостоятельной жизнью и претерпевал различные изменения связанные с современными тенденциями (например, с развитием платформы .NET) развития языков программирования: появились class helpers, перегрузки операторов и другое.

Изначально среда разработки была предназначена исключительно для разработки приложений Microsoft Windows, затем был реализован также для платформ Linux (как Kylix), однако после выпуска в 2002 году Kylix 3 его разработка была прекращена, и, вскоре после этого, было объявлено о поддержке Microsoft .NET.
Реализация среды разработки проектом Lazarus (Free Pascal, компиляция в режиме совместимости с Delphi) позволяет использовать его для создания приложений на Delphi для таких платформ, как Linux, Mac OS X и Windows CE.
Также предпринимались попытки использования языка в проектах GNU (например, Notepad GNU) и написания компилятора для GCC.

Object Pascal — результат развития языка Турбо Паскаль, который, в свою очередь, развился из языка Паскаль. Паскаль был полностью процедурным языком, Турбо Паскаль, начиная с версии 5.5, добавил в Паскаль объектно-ориентированные свойства, а в Object Pascal — динамическую идентификацию типа данных с возможностью доступа к метаданным классов (то есть к описанию классов и их членов) в компилируемом коде, также называемом интроспекцией — данная технология получила обозначение RTTI. Так как все классы наследуют функции базового класса TObject, то любой указатель на объект можно преобразовать к нему, после чего воспользоваться методом ClassType и функцией TypeInfo, которые и обеспечат интроспекцию.


Итак, на языке программирования Delphi с использованием концепций объектно-ориентированного программирования было разработано приложение. Данное приложение распознаёт ноты в файлах формата WAV, и записывает их в файл формата MIDI. Для этого используется быстрое преобразование Фурье -   алгоритм быстрого вычисления дискретного преобразования Фурье, которое позволяет разложить звуковую волну, записанную в исходном файле, на элементарные составляющие — гармонические колебания с разными частотами. Далее после анализа этих гармоник мы и получаем ноты, которые записываются в выходной файл.

Итого, в работе содержится \ESKDtotal{page} страниц, \ESKDtotal{figure} рисунков и \ESKDtotal{table} таблиц.
\clearpage
\section{ЗАДАЧА РАСПОЗНАВАНИЯ МУЗЫКИ}
\subsection{ Содержательное описание задачи}
Задачей данной работы является построение системы, осуществляющей идентификацию музыкальных структур в данных, представленных в виде отсчетов акустических сигналов (WAV-файл) и запись их в некоторой музыкальной нотации (MIDI-файл), т.е. задача, известная как "распознавание музыки" (music recognition).

"Распознавание музыки" может быть определено как процесс прослушивания частей музыкального произведения и запись в музыкальной нотации нот, которые присутствуют в этих частях. Это реализуется с помощью с помощью извлечения специфической информации из музыкальных звуковых сигналов, и в результате получается символическое представление совокупности нот, их высоты, пауз, динамики и, возможно, информацию о использованных инструментах.

Люди без музыкального образования часто испытывают больше трудностей при распознавании полифонической (в которой одновременно звучит больше одной ноты) музыки, чем музыкально-подготовленные люди. Опыт музыкального стиля, звуков инструментов и познания в музыкальной теории может дать слушателям возможность понимания более сложной и богатой полифонии, сочетающей большое количество различных инструментов и музыкальных стилей. 

Автоматическое распознавание музыки привлекает внимание музыкантов и компьютерных специалистов в течение более двадцати пяти лет.

Исследования в области автоматического распознавания музыки проводятся в рамках различных областей науки.

Психоакустика пытается установить зависимость между акустическими сигналами, психологии человеческой системы слуха и восприятия звука. Эта наука основывается еще на знаниях Древней Греции, когда Пифагор заметил, что колеблющиеся одновременно струны звучат хорошо,когда их длины относятся друг к другу как малые целые числа.

Уже в XX-ом веке ряд ученых положили начало эволюции в области психоакустики, которая стала нацелена на глубокое понимание психофизики слуха. Благодаря этим людям, были созданы точные и хорошо протестированные модели, фокусирующиеся на базовых способностях восприятия (восприятие высоты и громкости) как на простых стимулах и на том, что один простой звук маскирует другой во временном пространстве.

Кроме того, частью процесса автоматического распознавания музыки должна быть идентификация музыкальных инструментов, участвующих в музыкальном фрагменте, и автоматический расчет темпа и ритма музыки. Эти параметры очень важны для системы распознавания, так как именно они помогают человеческому мозгу создать точную и целостную картину музыкального образа.

Существует множество способов применения систем восприятия музыки, но все они ограничены из за низкой надежности результатов, предоставляемых текущими решениями.

Однако, достаточно просто указать некоторые области применения для уже существующих и создаваемых в будущем систем:

1. Собственно системы распознавания музыки. Эти системы заинтересуют композиторов и музыкантов, которые хотят эффективно анализировать композиции, имя у себя лишь звуковые записи. Получаемое в результате такой системы символическое представление музыки является гибким для музыкального анализа, редактирования и смешивания, которое вручеую было бы слишком сложно или попросту не возможно.

2. Алгоритмическая композиция. Имеющиеся на текущий системы компьютерной композиции могут улучшить результаты в оценке человеком. Если машины смогут понимать созданную ими музыку, они смогут проверять созданную ими музыку и будут "самокритичными". Это также позволит увеличить степень автоматизации процесса композиции.

3. Визуализация музыки. Можно создавать различные  мультимедийные  приложения, создающие зрительные и иные образы, каким-либо способом синхронизированные с музыкой.

4. Создание музыкальных баз данных. С использованием систем распознавания музыки можно создавать базу данных, в которой можно будет найти полную информацию о фрагменте музыкального произвеления с помощью небольшого его фрагмента. Кроме того, основываясь на данных этой базы можно будет подбирать незнакомую раннее музыку, просто указав свои предпочтения.

5. Структурное кодирование музыки. Использование системы распознавания музыки может использоваться для поиска эквивалентно звучащих звуков, и позволит увеличить качество и уменьшить размер закодированной музыки, как это делается в архиваторах.

6. Автоматизированные системы обучения. Использование систем распознавания музыки позволит создать новое поколение систем обучение музыки, котрое позволит изучать музыку на расстоянии (например, через Интернет), и позволит получать более глубокие познания в музыке.

Распознавание музыки - сложная задача, поскольку в данном процессе необходимо учитывать большое количество параметров и наличие сложных взаимосвязей между ними. Поэтому ниже вводятся некоторые, самые важные, понятия и определения, которые могут получить представление о структуре и этапах решения данной задачи.

К сожалению, трудно найти объективное и формализованное определения музыки. Давалось множество определений как теоретиками музыки, так и музыкантами. Приведём некоторые из них:
Музыка - искусство стройного и согласного сочетания звуков, как последовательных (мелодия, напев, голос), так и совместных (гармония, согласие, созвучие); равно искусство это в действии.

Музыка -  есть искусство пения и пляски, позже совокупность всех изящных искусств, необходимых для гармонического развития духа, в противоположность гимнастике, искусству воспитания красивого тела. 2) Искусство воспроизведения в звуках чувств и настроений с целью вызвать в слушателе соответствующие чувства и настроения. Главные элементы музыки: ритм, мелодия и гармония. Различают по содержанию музыку: церковную и светскую, по средствам исполнения: инструментальную и вокальную. Инструм. музыка делится на оркестровую и камерную, по роду инструментов на духовую и смычковую.


Музыка (от греч. musikе, буквально - искусство муз), вид искусства, который отражает действительность и воздействует на человека посредством осмысленных и особым образом организованных звуковых последований, состоящих в основном из тонов (звуков определённой высоты). Музыка - специфическая разновидность звуковой деятельности людей. С др. разновидностями (речь, инструментально-звуковая сигнализация и т. д.) её объединяет способность выражать мысли, эмоции и волевые процессы человека в слышимой форме и служить средством общения людей и управления их поведением. В наибольшей степени Музыка сближается с речью, точнее, с речевой интонацией, выявляющей внутреннее состояние человека и его эмоциональное отношение к миру путём изменений высоты и др. характеристик звучания голоса. Это родство позволяет говорить об интонационной природе Музыки. Вместе с тем Музыка существенно отличается от всех остальных разновидностей звуковой деятельности людей. Сохраняя некоторое подобие звуков реальной жизни, музыкального звучания принципиально отличаются от них строгой высотной и временной (ритмической) организованностью. Эти звучания входят в исторически сложившиеся системы, основу которых составляют тоны, отобранные музыкальной практикой данного общества.
 
Наверное, после рассмотрения вышеуказанных определений, можно лишь сказать что музыка - понятие достаточно философское и многогранное, поэтому мы будем говорить не столько о музыке, сколько об её акустической стороне - совокупности гармонических колебаний.

В традиционной музыкальной нотации Запада (на Востоке существует множество различных музыкальных нотаций, и причем все они достаточно специфические и экзотичные с точки зрения западного человека) основным элементом и понятием является нота - фундаментальный символ, отображающий звук, получаемый с помощью музыкального инструмента. Такое определение ноты включает в себя такие свойства, как высота, громкость и ритм, и, во многих случаях также и тембр.

Высота ноты кореллирует с частотой одного гармонического тона, поэтому можно упорядочить музыкальные звуки по высоте - от низших к высшим.

Когда мы берем единственную ноту на музыкальном инструменте с частотой, допустим $f$, это означает на самом деле, что звук также имеет ещё и отзвуки с частотами, кратными данной частоте. При понимании этого эффекта может помочь теория Фурье, которая утверждает, что любой гармонический звук может быть разложен на сумму различных синусоид(чистых тонов) с различными фазами и частотами, кратными основной частоте, т.е. $2f,3f...$ и т.д. Тогда частота $f$  называется основной частотой гармонического звука. Противоположностью гармонического звука являются не-периодические, хаотические колебания, которые очень сложно подогнать под эту модель.

Синусоида с частотой, кратной основной частоте называется обертоном. Можно считать, что гармоника с базовой частотой является нулевым обертоном.

Громкость является ощущаемым свойством звука, которое имеет связь с физической величиной интенсивности звука. По этому свойств звук может иметь характеристики от "тихого" до "громкого". Связь между громкостью и интенсивностью похода на связь между высотой и частотой.

В музыкальном контексте, это свойство является базой динамики музыкальной фразы (долговременного последовательного изменения громкости последовательности музыкальных нот).

Определение громкости может быть основано на подсчете мощности записанного сигналов

Темп звука является свойством ощущения того, как часто звук повторяется с некоторым интервалом - обычно от 250 миллисекунд до 2 секунд. Темп является достаточно относительным ощущением, однако при указании минимальной длительности ноты его можно восстановить из ритмического рисунка - отношения длительностей различных нот.

Тембр может быть определен как набор качеств, по которым слушатели могут определить играющий музыкальный инструмент. Он зависит от относительных магнитуд гармоник. 
 
\subsection{Математическая формулировка задачи}
Дана последовательность отсчетов некоторого сигнала $f(t)$. Разложить данный сигнал на сумму сигналов с определенными частотами: $\omega_i=f_0 \cdot 2^i$, где $f_0$ - частота камертона - равна 440 Гц.
\subsection{Обсуждение задачи}
Итак, определим - какой же главный параметр должен быть определен на этапе распознавания? Как видно из описания задачи, а особенно её математической формулировки - это высота звука.

Высота звука, как было указано, напрямую связана с частотой гармоник, простых тонов, поэтому для успешного решения задачи нам необходим алгоритм, который мог бы дать нам данные об амплитудах этих гармоник на выходе, т.е. зависимость амплитуды от частоты, имея на входе зависимость амплитуды от времени. В терминах теории обработки сигналов такие методы называются методами преобразования из временного пространства в частотное пространство 
, и такие методы рассматриваются в следующем разделе.
\clearpage
\section{ВЫБОР И ОБОСНОВАНИЕ ЧИСЛЕННОГО МЕТОДА РЕШЕНИЯ ЗАДАЧИ}

\subsection{Методы промежуточного представления акустических сигналов}
Как уже говорилось,  музыка может быть рассмотрена на разных уровнях: от музыки
теоретическом уровне (как правило, связано с символическим представлением музыки - ноты) до
уровня восприятия (как человеческое сознание воспринимает акустический сигнал)
и как физическое явление (связанное с акустикой понятие
музыки).

Далее в  тексте, форма волны акустического музыкального сигнала будет рассматриваться как представление низкого уровня, а
нотная запись  будет рассматриваться как представление высокого уровня.
Так как музыкальные символы  не могут быть непосредственно
выделены из акустического сигнала,   сигнал должен быть сначала приведен к представлению среднего уровня.
При определении вида такого среднего уровня, нужно принимать во внимание ограничения
и сильные стороны, которые он накладывает на  "верхний уровень" музыкального сигнала во время
процесса сокращения числа объектов "нижнего уровня" в нем. Выбранное представление должно легко
отвечать на вопросы более высокого уровня переработки и с использованием наиболее эффективных
вычислительный методов.

В следующих пунктах представлены некоторые из наиболее важных представлений среднего уровня  для
музыкальных сигналов.

Ом и Гельмгольц впервые заметили, что ухо, как анализатор Фурье,делит звук
на спектральные составляющие, положили начало обсуждениям обработки сигнала в ухе.
Их выводы  широко используются в спектральном представлении звука в аудиоприложениях.
Такой вид представления среднего уровня был предметом многих  исследований, кроме того,
 развитие быстрого преобразования Фурье (БПФ), как вычислительно-эффективного способа вычисления ДПФ добавило популярности Фурье-анализу и синтезу
 во многих научных и технических приложениях.

Однако есть некоторые различия между спектральным анализом, выполняемым человеческой
слуховой системой, и стандартным анализом по методам Фурье. Наиболее важным отличием является то,
что слуховая система раскладывает спектр по логарифмической шкале, тогда как традиционный анализ Фурье
вычисляет спектр с линейной шкалой. Другое отличие состоит в том, что реализация на основе спектра Фурье
 не рассматривает другие особенности слуховой системы, такие как
маскировка явлений во временном и частотном пространстве, ни различий в
восприятии громкости в связи с частотой. Эти различия должны быть приняты во
внимание, с связи с тем, что они могут быть исправлены или, по крайней мере приняты во внимание при толковании
результаты анализа.

В любом случае, Фурье-представление является очень эффективным решением для анализа
звуковых сигналов, в частности в случае транскрипции акустических музыкальных сигналов. 
Вышеуказанные недочеты должны быть приняты во внимание лишь тогда, когда они чрезмерно искажают результат, что случается не так уж и часто.

Для того чтобы преодолеть недостатки ДПФ в области восприятия, некоторые авторы предложили Constant Q
Transform(CQT) в качестве базы для анализа сигналов в системах восприятия музыки. В кратце, благодаря экспоненциальной частоте дискретизации  некоторого банка фильтров имитируется
 человеское восприятия интервалов - октава звучит одинаково в широком
диапазон частот.

По сравнению с БПФ, CQT является лучшим приближением к стандартной модели улитки человеческого уха.
Тем не менее, расчет частот с помощью БПФ имеет гораздо большую
эффективность. Кроме того, каждая подпоследовательность при БПФ имеет одинаковую ширину, что также приводит к более простой
архитектуре.

Кроме того, в некоторых работах промежуточное представление сигналов в системе автоматической транскрипции музыки было основано на использовании
кореллограмм. Применение данного метода дает весьма неплохие результаты, однако весьма трудоёмко.

Исходя из вышесказанных соображений, в данной работе для получения промежуточного представления сигнала используется быстрое преобразование Фурье 
- как мощный, качественный и проверенный метод для получения частотного спектра.

\subsection{Быстрое преобразование Фурье}
Для разложения входного сигнала на базовые гармоники можно использовать алгоритм дискретного преобразования Фурье (ДПФ). Однако расчет ДПФ, содержащего N коэффициентов, потребует $N^2$ пар операций «умножение-сложение». Число операций возрастает пропорционально квадрату размерности ДПФ. Однако, если $N$ не является простым числом и может быть разложено на множители, процесс вычислений можно ускорить, разделив анализируемый набор отсчетов на части, вычислив их ДПФ и объединив результаты. Такие способы вычисления ДПФ называются быстрым преобразованием Фурье (БПФ; английский термин — Fast Fourier Transform, FFT) и повсеместно используются на практике.
При реализации БПФ возможно несколько вариантов организации вычислений в зависимости от способа деления последовательности отсчетов на части (прореживание по времени либо по частоте) и от того, на сколько фрагментов производится разбиение последовательности на каждом шаге (основание БПФ).
БПФ с прореживанием по времени
Рассмотрим идею БПФ с прореживанием по времени (decimation in time, DIT) на примере деления набора отсчетов пополам.
Итак, пусть $N$ — четное число. Выделим  два слагаемых, соответствующих элементам исходной последовательности с четными и нечетными номерами:
\begin{equation}
\nonumber
X(n)=\sum_{m=0}^{N/2-1} x(2m)e^{-j \frac{2\pi 2mn}{N}}+\sum_{m=0}^{N/2-1} x(2m+1)e^{-j \frac{2\pi (2m+1)n}{N}}
 \end{equation}
Введем обозначения $y(m) = x(2m)$ и $z(m) = x(2m+1)$, а также вынесем из второй суммы общий множитель $e^{\frac{-2j\pi n}{N}}$:
\begin{equation}
\nonumber
X(n)=\sum_{m=0}^{N/2-1} y(m)e^{-j \frac{2\pi 2mn}{N}}+e^{\frac{-2j\pi n}{N}}\sum_{m=0}^{N/2-1} z(m)e^{-j \frac{2\pi 2mn}{N}}
 \end{equation}
Две суммы  представляют собой ДПФ последовательностей $\{y(m)\}$ (отсчеты с четными номерами) и $\{z(m)\}$ (отсчеты с нечетными номерами). Каждое из этих ДПФ имеет размерность $N/2$. Таким образом,
\begin{equation}
\nonumber
X(n)=Y(n)+e^{\frac{-2j\pi n}{N}}Z(n),
 \end{equation}
где $Y(n)$ и $Z(n)$ — ДПФ соответственно последовательностей отсчетов с четными и нечетными номерами:
\begin{align}
\nonumber
&Y(n)=\sum_{m=0}^{N/2-1} y(m)e^{-j \frac{2\pi 2mn}{N}}\\
\nonumber
&Z(n)=\sum_{m=0}^{N/2-1} z(m)e^{-j \frac{2\pi 2mn}{N}}
 \end{align}
Так как ДПФ размерности $N/2$ дает лишь $N/2$ спектральных коэффициентов, непосредственно использовать вышеприведенные две формулы можно только при $0 < n < N/2$. Для остальных $n (N/2 < n < N)$ следует воспользоваться периодичностью спектра дискретного сигнала (и, соответственно, периодичностью результатов ДПФ):
\begin{equation}
\nonumber
Y(n+\frac N 2)=Y(n),Z(n+\frac N 2)=Z(n)
 \end{equation}
С учетом этого при $n \ge N/2$  получаем:
\begin{equation}
\nonumber
X(n)=Y(n-\frac N 2)+e^{\frac{-2j\pi}{N}(n-\frac N 2)}Z(n-\frac N 2)
 \end{equation}
Оценим количество операций, необходимое для вычисления ДПФ указанным способом. Каждое из двух ДПФ половинной размерности требует $N^2/4$ операций. Кроме того, при вычислении окончательных результатов каждый спектральный коэффициент $Z(n)$ умножается на экспоненциальный комплексный множитель. Это добавляет еще $N/2$ операций. Итого получается $2 N^2 /4 + N/2 = N(N + 1)/2$, что почти вдвое меньше, чем при вычислении ДПФ прямым способом.
Если $N/2$ тоже является четным числом (то есть если $N$ делится на 4), можно продолжить описанную процедуру, выразив результат через четыре ДПФ размерности $N/4$. Это позволяет еще больше сократить число требуемых вычислительных операций.

Делить исходную последовательность можно на любое количество частей. Таким образом, приведенный алгоритм позволяет уменьшить число операций в случае любого N, не являющегося простым числом. Степень ускорения вычислений зависит от числа фрагментов последовательности и является максимальной при делении на две части, как в рассмотренном примере.
Наибольшая степень ускорения вычислений может быть достигнута при $N = 2^k$, в этом случае деление последовательностей на две части можно продолжать до тех пор, пока не получатся двухэлементные последовательности, ДПФ которых рассчитывается вообще без использования операций умножения (достаточно вычислить сумму и разность двух отсчетов). Число требуемых при этом пар операций «умножение — сложение» можно оценить как $N\log_2(N)$. Таким образом, вычислительные затраты по сравнению с непосредственным использованием ДПФ уменьшаются в $N\log_2(N)$ раз. При больших $N$ это отношение становится весьма велико (например, $1024/\log_2(1024) = 102,4$, то есть при $N = 1024$ достигается более чем 100-кратное ускорение).

Формулы прямого и обратного ДПФ  отличаются только знаком в показателе экспоненты и множителем перед суммой. Поэтому можно получить еще один вариант алгоритма БПФ. Этот способ вычислений называется прореживанием по частоте (decimation in frequency, DIF). 
Разделим исходную последовательность x(k) на две следующие друг за другом половины (как и в предыдущем случае, N должно быть четным числом):
\begin{equation}
\nonumber
X(n)=\sum_{m=0}^{N/2-1} x(2m)e^{-j \frac{2\pi 2mn}{N}}+\sum_{m=0}^{N/2-1} x(m+N/2)e^{-j \frac{2\pi (m+N/2)n}{N}}
 \end{equation}
Из второй суммы можно выделить множитель
\begin{equation}
\nonumber
e^{-j \frac{2\pi (N/2)n}{N}}=e^{(-j\pi n)}=(-1)^n.
\end{equation}
Этот множитель равен 1 или -1 в зависимости от четности номера вычисляемого спектрального отсчета $n$, поэтому дальше рассматриваем четные и нечетные $n$ по отдельности. После выделения множителя 1 комплексные экспоненты в обеих суммах становятся одинаковыми, поэтому выносим их за скобки, объединяя две суммы:
\begin{align}
\nonumber
&X(2k)=\sum_{m=0}^{N/2-1}\left( x(2m)+x(m+N/2)\right)e^{-j \frac{2\pi mk}{N/2}}\\
\nonumber
&X(2k+1)=\sum_{m=0}^{N/2-1}\left( x(2m)+x(m+N/2)\right)e^{-j \frac{2\pi mk}{N/2}}e^{-j \frac{2\pi m}{N}}
 \end{align}
Фигурирующие здесь суммы представляют собой ДПФ суммы и разности половин исходной последовательности, при этом разность перед вычислением ДПФ умножается на комплексные экспоненты $exp(-j2nm/N)$. Каждое из двух используемых здесь ДПФ имеет размерность $N/2$.


В названиях алгоритмов БПФ можно встретить слово «RADIX» («основание» — в математическом смысле). Следующее после него число обозначает число фрагментов, на которое разбивается сигнал на каждом этапе прореживания (а также минимальный размер «кусочков» входного вектора, который достигается в результате его последовательных разбиений).
В алгоритмах «RADIX-2» размер анализируемой последовательности должен быть равен степени двойки, а ее половинное деление производится вплоть до получения двухэлементных последовательностей. Вычисление их ДПФ не требует операций умножения — два спектральных отсчета представляют собой сумму и разность отсчетов временных:
\begin{align}
\nonumber
&X(0) = x(0) + x(1),\\
\nonumber
&X(1) = x(0)-x(1).
 \end{align}
В алгоритмах «RADIX-4» количество отсчетов сигнала должно быть равно степени четверки, при каждом прореживании сигнал делится на четыре фрагмента, а последней стадией деления являются четырехэлементные последовательности. При вычислении их ДПФ умножение производится только на j, а такое умножение сводится к взаимной перестановке вещественной и мнимой частей комплексного числа с изменением знака у одной из них:
 \begin{align}
\nonumber
&X(0) = x(0) + x(1) + x(2) + x(3), \\
\nonumber
&X(1) = x(0) - jx(1)-x(2) + j x(3), \\
\nonumber
&X(2) = x(0) - x(1) + x(2)-x(3), \\
\nonumber
&X(3) = x(0) + j x( 1) - x(2) - j x(3).
\end{align}
\clearpage
\section{РАЗРАБОТКА АЛГОРИТМА}
\subsection{Структуры данных}
Итак, после выбора главного алгоритма разрабатываемой программы, можно приступить к её разработке и реализации.

Введём сначала обозначения и поясним предназначение переменных и структур данных, которые могут встретиться в программе.

Как уже говорилось, входные данные для программы будут представленные в формате WAV, который в свою очередь является подмножеством формата RIFF (Rich Interchange File Format), разработанного Microsoft. Данный формат является достаточно общим (достаточно сказать, что формат MIDI, который имеет совершенно другую логику, также описывается практически тем же форматом), поэтому он насыщен различного рода метаданными, однако с нашей точки зрения кажется важным лишь то, что сами полезные данные WAV могут быть представлены как последовательность отсчетов, модули которых имеют абсолютное значение - импульсно-кодовая модуляция (ИКМ; Pulse-Code Modulation, PCM), или являются разницей от предыдущего отсчета - в данном случае говорят об адаптивной дельта ИКМ (Adaptive-Delta PCM,ADPCM). Для нас более удобен первый вариант, и поэтому будем испольлзовать именно его, поэтому структуре данных, представляющей входные данные дадим имя WavPCM.

Также нам понадобятся данные о количестве точек, на которых будет применено БПФ. Обозначим данную переменную как FCount.  Также потребуется массив длинной FCount для временного хранения считанных из WavPCM отсчетов, обозначим его как Temp. 

При использовании итеративного преобразования Фурье, которое имеет преимущества в быстродействии перед рекурсивным, нам потребуется переставить исходные данные определенным образом. Обозначим массив, значения которого указывают на место элемента с данным индексом в преобразованном массиве, как IndexTable. Кроме того, комплексные экспоненты, участвующие в преобразовании, можно рассчитать заранее, что может повысить скорость обработки. Поэтому сохраним данные экспоненты (также называемые поворачивающими множителями) в массив под названием ExpTable. 

Так как классическое преобразование Фурье предполагает, что входной сигнал является стационарным (то есть является постоянным, единым процессом в течение своей продолжительности), то музыкальное произведение, в котором сигналы-ноты могут сменятся до нескольких раз в секунду, не подходит под эти требования. Однако, если считать сами ноты достаточно стационарными сигналами, то появляется возможность провести оконное преобразование Фурье, и рассчитывать БПФ на небольшом временном отрезке. Поэтому при анализе исходного сигнала приходится проводить не одно, а несколько преобразований Фурье. Соотвественно, будем сохранять результаты этих преобразований в массив. Получается, что тогда результаты анализа представляют собой двумерный массив, верхний индекс которого указывает номер временного участка, на котором проводилось преобразование, и нижний индекс которого является номером гармоники, полученным в результате данного преобразования. Обозначим данную структуру данных как Fourier.

После этого мы готовы будем приступить к получению MIDI-файла. Данный формат файла имеет с форматом WAV схожую форму, но совершенно другое смысловое наполнение. Если WAV-файл содержит просто замер амплитуды сигнала в каждый момент времени, то в MIDI-файле сохранены команды инструментам, когда исполнять ноту той или иной высоты в каждый момент времени. Так как имеется прямая зависимость между высотами нот и некоторыми соответствующими гармониками, то для получения информации о нотах мы должны провести анализ гармоник соответствующих частот.
 
Итак, после завершения спектрального анализа Фурье, мы должны провести гармонический анализ, который, используя информацию о гармониках, даст нам информацию о нотах, звучащих во время каждого временного участка оконного преобразования Фурье, то есть получим данные о высотах нот и времени из звучания. Этих данных достаточно, чтобы получить MIDI-файл. Итак, обозначим эти данные как MIDIData.

Теперь иы ввели все основные структуры данных, что позволяет перейти к этапу разработки алгоритма. 
\subsection{Структура алгоритма}
Итак, обрисуем словами алгоритм по получению MIDI-файла из файла WAV.

Сначала мы получаем входные данные WavPCM и параметр FCount.

Далее мы считываем данные из WavPCM порциями по FCount отсчетов, и применяем к каждой такой порции БПФ. В результате этой операции мы получаем двумерный массив Fourier, в котором верхний индекс указывает номер участка, на котором проводилось преобразование, и нижний индекс которого является номером гармоники, полученным в результате данного преобразования.

Далее к полученным данным применяется процедура гармонического анализа, и в результате мы получаем выходные данные MidiData. Эти данные и являются результатом работы алгоритма. 
\subsection{Схема алгоритма}
На рисунке \ref{LAB0} представлена схема общего алгоритма преобразования WAV-файла в MIDI-файл.
\pic{LAB0.png}{Схема общего алгоритма преобразования WAV-файла в MIDI-файл}{LAB0}{H}
На рисунке \ref{LAB1} представлена схема алгоритма получения для перемешивания исходных данных при подготовке их к БПФ.
\pic{LAB1.png}{Схема алгоритма  перемешивания  данных}{LAB1}{H}
На рисунке \ref{LAB2} представлена схема алгоритма получения поворачивающих множителей - комплексных экспонент, коэффициентов БПФ.
\pic{LAB2.png}{Схема алгоритма  получения поворачивающих множителей}{LAB2}{H}
На рисунке \ref{LAB3} представлена схема алгоритма БПФ - быстрого преобразования Фурье.
\pic{LAB3.png}{Схема алгоритма БПФ}{LAB3}{H}
\clearpage
\section{ТЕКСТ ПРОГРАММЫ}
\subsection{Описание переменных и структур данных}
Переменные программы распознавания нот в WAV-файле  \ftab{prog:2}.
\tabl{Переменные программы  распознавания нот}{
\tabln{MidiPort,MidiStatus&Integer&Порт MIDI и статус его открытия}
\tabln{instr\_indexes&array of byte&индексы используемых инструментов MIDI}
\tabln{pcount&integer&\tabbox{9cm}{\raggedright количество точек при построении графика звуковой волны}}
\tabln{ UsedWindow&byte&индекс используемой оконной функции}
\tabln{ FCount&Integer&количество точек для преобразования}
\tabln{FCount\_1&Integer&\tabbox{9cm}{\raggedright количество точек для преобразования минус 1}}
\tabln{ FCountDiv2&Integer&половина точек для преобразования}
\tabln{ FCountDiv2\_1&Integer&\tabbox{9cm}{\raggedright половина точек для преобразования минус 1}}
\tabln{ norm&Double&нормирующий множитель амплитуды}
\tabln{MaxAmplitude&Double&максимальная амплитуда среди гармоник}
\tabln{Eps&Double&\tabbox{9cm}{минимальная учитываемая амплитуда гармоники}}
\tabln{ UpdateTrack&Boolean&флаг обновления ползунка проигрывателя}
\tabln{AnalyzeComplete&Boolean&флаг проведения спетроанализа}
\tabln{WaveLoaded&Boolean&флаг получения WAV-файла}
\tabln{MidiCreated&Boolean&флаг создания MIDI-данных}
\tabln{ MidiSaved&Boolean&флаг сохранения MIDI-данных}
\tabln{ Form1&TForm1&форма программы}
\tabln{ WavPCM& TPCMWaveFile&WAV-файл}
\tabln{ Fourier&\tabbox{3cm}{\centering array of \\ TCmxArray}&массив гармоник}
}{prog:2}{H}
 
\subsection{Описание функций}
1. Функция GetFFTExpTable возвращает массив поворачивающих множителей для
преобразования Фурье длиной Count точек. При истинном значении
параметра Inverse получаются множители для обратного БПФ, иначе - для
прямого.

function GetFFTExpTable(Count:Integer; Inverse:Boolean=False): TCmxArray;

Параметры  функции \ftab{GetFFTExpTable:1}:
\tabl{Параметры  функции расчета поворачивающих множителей}{
\tabln{Count&Integer&количество точек БПФ}
\tabln{Inverse&Boolean&тип преобразования: прямое/обратное}
}{GetFFTExpTable:1}{H}
Локальные переменные  функции \ftab{:2}:
\tabl{Локальные переменные  функции расчета поворачивающих множителей}{
\tabln{j,i&Integer&счётчики для обработки массивов}
\tabln{w&TComplex&текущий рассчитанный множитель}
\tabln{wn&TComplex&комплексный коэффициент расчета следующего множителя}
\tabln{k&Double&начальный коэффициент расчета}
}{GetFFTExpTable:2}{H}

2. Функция GetArrayIndex возвращает массив длиной Count, согласно значениям которого нужно
перемешивать исходные данные БПФ также длины Count.

function GetArrayIndex(Count: Integer): TIndexArray;

Параметры  функции \ftab{GetArrayIndex:1}:
\tabl{Параметры  функции расчета индексов перемешивания}{
\tabln{Count&Integer&количество точек БПФ}
}{GetArrayIndex:1}{H}

Локальные переменные  функции \ftab{GetArrayIndex:2}:
\tabl{Локальные переменные  функции  расчета индексов перемешивания}{
\tabln{I,j,k,k2&Integer&счётчики для обработки массивов}
\tabln{i\_2&Integer&половина значения i}
\tabln{Temp&TIndexArray&часть массива для перемешивания}
}{GetArrayIndex:2}{H}

3. Процедура FFT преобразует массив отсчетов D в массив БПФ с помощью поворачивающих множителей TableExp.

procedure FFT(var D: TCmxArray; const TableExp: TCmxArray);

Параметры процедуры \ftab{FFT:1}:
\tabl{Параметры процедуры расчета БПФ}{
\tabln{D&TCmxArray&массив для БПФ}
\tabln{TableExp&TCmxArray&поворачивающие множители}
}{FFT:1}{H}


Локальные переменные  процедуры \ftab{FFT:2}:
\tabl{Локальные переменные  процедуры расчета БПФ}{
\tabln{I,J,K,ti&Integer&счётчики для обработки массивов}
\tabln{i\_2&Integer&половина значения i}
\tabln{Temp&TComplex&временная переменная}
}{FFT:2}{H}

\subsection{Текст программы}
Далее приводится текст модуля, написанного на языке Delphi 7, содержащего преобразование Фурье и связанные с ним процедуры:
\prog{Delphi}{../../src/Fourier/ModuleFFT.pas}
Далее представлен текст основного модуля программы поиска нот в WAV-файле, написанной на языке Delphi 7.
\prog{Delphi}{../../src/Fourier/UnitMain.pas}
Ниже представлен текст модуля управления настройками, написанного на языке Delphi 7:
\prog{Delphi}{../../src/Fourier/UnitSettings.pas}
Далее представлен текст модуля,  написанного на языке Delphi 7, содержащего объекты для работы с WAV-файлами:
\prog{Delphi}{../../src/Fourier/ModuleWAV.pas}
Ниже приводится текст модуля, написанного на языке Delphi 7, реализующего операции с комплексными числами:
\prog{Delphi}{../../src/Fourier/ModuleComplex.pas}
\clearpage
\section{ТЕСТОВАЯ ЗАДАЧА}
\subsection{Аналитическое решение и умозрительные результаты}
Итак, приступим к тестированию полученной программы.

Пусть входными данными будем WAV-файл, в котором содержится запись проигранных на фортепиано аккордов, представленных на рисунке \ref{SCR1}.

\pic{SCR1.png}{Тестовый пример для распознавания}{SCR1}{H}

Какими же критериями следует руководствоваться при оценке полученных результатов?

Основным показателем правильности работы алгоритма БПФ является присутствие всех без исключения нот в выходных данных. Мы допускаем присутствие лишних нот вследствие возможных шумовых и иных искажений спектра входных данных, а также регистрации обертонов.

Отношение к временным показателям (т.е. как распознанные ноты располагаются по времени) также не должно быть слишком строгим, так как в случае фортепиано после нажатия ноты она ещё некоторое время продолжает звучать (если не была нажата педаль). Поэтому следует ожидать небольшое "смазывание" результирующих аккордов вследствие регистрации отзвуков.
\subsection{Решение, полученное с использованием разработанного ПО}
Ниже на рисунке \ref{SCR2} представлен пример работы программы при обработке вышеуказанных входных данных.
\pic{SCR2.png}{Пример работы программы  при обработке данных}{SCR2}{H}
На рисунке \ref{SCR3} представлена клавишная табулатура, полученная программой в результате работы.
\pic{SCR3.png}{Клавишная табулатура, полученная программой}{SCR3}{H}
На рисунке \ref{SCR4} представлен полученный MIDI-файл, открытый в нотном редакторе. Импортируемые длины нот округлялись до $\frac{1}{4}$. 
\pic{SCR4.png}{Результат с округлением до  $\frac{1}{4}$}{SCR4}{H}
На рисунке \ref{SCR5} открыт тот же файл, но когда импортируемые длины нот округлялись до $\frac{1}{8}$. 
\pic{SCR5.png}{Результат с округлением до  $\frac{1}{8}$}{SCR5}{H}
\subsection{Выводы}
Итак, рассматривая рисунки \ref{SCR4} и \ref{SCR5}, убеждаемся, что программа работает верно:

1. Все присутствующие ноты были распознаны программой.

2. К каждому аккорду сверху добавился первый обертон третьей ступени, т.е. третья ступень на октаву выше.

3. Вследствие отзвуков переход к текущему аккорду происходит не резко, а постепенно, что хорошо видно на рисунке \ref{SCR5}. Это обстоятельство и дало в аккордах лишние ноты на рисунке \ref{SCR4}. 

Полученные результаты полностью соответствуют описанным раннее ожиданиям, поэтому можно считать, что программа работает верно и получает удовлетворительные результаты. 
\clearpage
\section{ИНСТРУКЦИЯ ПОЛЬЗОВАТЕЛЮ}
Данная программа предназначена для нахождения нот в WAV-файле и  сохранения их в MIDI-файл.

Сначала выберите исходный файл с помощью кнопки выбора файла на форме программы, либо с помощью меню.
После этого можно перейти к спектральному анализу, а можно построить график звуковой волны, сохраненной в файле.

Для проведения спектроанализа выберите необходимые параметры, после чего нажмите соотвествующую кнопку.

После этого выберите имя выходного файла с помощью соответствующей кнопки на форме программы. Впрочем, та операция может быть проведена позже с помощью меню.

После этого выберите минимальную учитываемую амплитуду. Чем меньше величина, тем больше может быть найдено нот, однако к результату могут примешаться и шумы. После этого нажмите кнопку "Поиск нот". Программа проведет анализ, и сохранит ноты в указанном файле, а также нарисует клавишную табулатуру. Повторяйте три предыдущих шага, пока не добьётесь наилучшего по вашему мнению результата.
\clearpage
\section*{ЗАКЛЮЧЕНИЕ}
\addcontentsline{toc}{section}{ЗАКЛЮЧЕНИЕ}
Итак, в данной работе было разработано программное обеспечение, успешно реализующее численный метод и применяющее его для решения инженерной задачи.

Программа написана на языке Delphi 7 с использованием методологии объектно-ориентированного программирования, которое чрезвычайно мощным и удобным инструментом при решении многих задач.

Алгоритм быстрого преобразования Фурье, используемый программой для нахождения нот в WAV-файле и  сохранения их в MIDI-файл, показал себя как мощный инструмент спектрального анализа, при этом являясь одним из наиболее эффективным в вычислительном плане среди других алгоритмов своего класса.

Однако не стоит останавливаться на достигнутом, ведь данные, получаемые методом быстрого преобразования Фурье, можно значительно улучшить с помощью последних достижений в алгоритмике: кореллограмм, нейронных сетей, генетических алгоритмов и т.д.

\clearpage
\section*{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
\addcontentsline{toc}{section}{СПИСОК ИСПОЛЬЗОВАННЫХ ИСТОЧНИКОВ}
1. А.Б. Сергиенко. Цифровая обработка сигналов.  - СПб.:Питер,2003.

2. Распознавание        аудиообразов с 
применением     
обертонового ряда. Волков А.В., ІНЖЕНЕРІЯ ПРОГРАМНОГО ЗАБЕЗПЕЧЕННЯ, 
№ 3  ,2010.

3. PCM TO MIDI TRANSPOSITION. Luis Gustavo Pereira Marques Martins, \\
Faculdade de Engenharia da Universidade do Porto, 2001

4 . Music: A Mathematical Offering, Dave Benson, Department of Mathematics, University of Aberdeen, 2008.

5. Волошинов А.В. Математика и искусство - 2-е изд. дораб и доп. - \\
М.:Просвещение,2000.
\end{document}